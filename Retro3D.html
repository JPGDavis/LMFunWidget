<html>
	<head>
		<style>
			body
			{
				margin: 0px;
				padding: 0px;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas" width="500" height="500"></canvas>
		<script>
			var debug = false;

			function Vert(x, y, z)
			{
				this.x = x;
				this.y = y;
				this.z = z;
			}

			function Coord(x, y)
			{
				this.x = x;
				this.y = y;
			}

			function Line(start, end)
			{
				this.start = start;
				this.end = end;
			}

			function Mesh(verts, lines)
			{
				 this.verts = verts;
				 this.lines = lines;
			}

			function Model(mesh)
			{
				this.x = 0;
				this.y = 0;
				this.z = 0;

				this.rotX = 0;
				this.rotY = 0;
				this.rotZ = 0;

				this.visible = true;
				this.mesh = mesh;

				this.color = "#FFFFFF";

				this.xLocs = new Int32Array(mesh.verts.length);
				this.yLocs = new Int32Array(mesh.verts.length);
			}

			var cubeVerts = [];
			cubeVerts.push(new Vert( 200, 200, 200));
			cubeVerts.push(new Vert(-200, 200, 200));
			cubeVerts.push(new Vert( 200, 200,-200));
			cubeVerts.push(new Vert(-200, 200,-200));
			cubeVerts.push(new Vert( 200,-200, 200));
			cubeVerts.push(new Vert(-200,-200, 200));
			cubeVerts.push(new Vert( 200,-200,-200));
			cubeVerts.push(new Vert(-200,-200,-200));
			cubeVerts.push(new Vert( 400, 200, 200));
			cubeVerts.push(new Vert(-400, 200, 200));

			var cubeLines = [];

			cubeLines.push(new Line(0,2));
			//cubeLines.push(new Line(5,1));
			cubeLines.push(new Line(3,7));
			cubeLines.push(new Line(7,5));


			cubeLines.push(new Line(3,1));
			//cubeLines.push(new Line(0,4));
			cubeLines.push(new Line(2,6));
			cubeLines.push(new Line(6,4));

			cubeLines.push(new Line(6,7));

			cubeLines.push(new Line(0,8));
			cubeLines.push(new Line(1,9));
			//cubeLines.push(new Line(4,5));

			var cubeMesh = new Mesh(cubeVerts, cubeLines);

			var models = new Array();

			for(var i = 0; i < 20; i++)
			{
				var cubeModel = new Model(cubeMesh);
				cubeModel.y = -600;
				cubeModel.z = 850 + (400 * i);
				models.push(cubeModel)
			}

			var time;

			var cnv = document.getElementById('canvas');
			var ctx = cnv.getContext('2d');
			ctx.lineWidth = 3;
			ctx.lineCap = "round";

			function update(delta)
			{
				for (var i = 0; i < models.length; i++)
				{
					var model = models[i];

					model.z -= (delta * 1);

					if(model.z < 700)
					{
						model.z += (400 * 10)
					}
					//model.rotX += (delta * 0.001);
				}
			}

			function transform()
			{
				// Bounds
				var xOffset = cnv.width	/ 2;
				var yOffset = cnv.height / 2;

				// Transform Models
				for (var i = 0; i < models.length; i++)
				{
					var model = models[i];

					if(model.visible)
					{
						for(var v = 0; v < model.mesh.verts.length; v++)
						{
							var x = model.mesh.verts[v].x;
							var y = model.mesh.verts[v].y;
							var z = model.mesh.verts[v].z;

							// Rotate X;
							if(model.rotX != 0)
							{
								var sinRot = Math.sin(model.rotX);
								var cosRot = Math.cos(model.rotX);

								var pY = y;
								y = y * cosRot - z * sinRot;
								z = pY * sinRot + z * cosRot;
							}

							// Rotate Y;
							if(model.rotY != 0)
							{
								var sinRot = Math.sin(model.rotY);
								var cosRot = Math.cos(model.rotY);

								var pX = x;
								x = x * cosRot + z * sinRot;
								z = z * cosRot - pX * sinRot;
							}

							// Calculate depth
							var depth = 300 / ((z - model.z) + 300);

							model.xLocs[v] = (x * depth) + xOffset;
							model.yLocs[v] = ((y + model.y) * depth) + yOffset;
						}
					}
				}
			}

			function render()
			{
				for (var i = 0; i < models.length; i++)
				{
					var model = models[i];

					if(model.visible)
					{
						ctx.strokeStyle = model.color;
						ctx.fillStyle = model.color;

						if(model.mesh.lines)
						{
							for(var l = 0; l < model.mesh.lines.length; l++)
							{
								var line = model.mesh.lines[l];

								ctx.beginPath();
								ctx.moveTo(model.xLocs[line.start],model.yLocs[line.start]);
								ctx.lineTo(model.xLocs[line.end],model.yLocs[line.end]);
								ctx.stroke();
							}
						}
						else
						{
							for(var s = 0; s < model.mesh.verts.length; s++)
							{
								ctx.beginPath();
								ctx.arc(model.xLocs[s], model.yLocs[s], 5, 0, 2 * Math.PI, false);
								ctx.fill();
							}
						}

						if(debug)
						{
							for(var s = 0; s < model.mesh.verts.length; s++)
							{
								ctx.fillStyle = model.color;
								ctx.fillText(s, model.xLocs[s], model.yLocs[s])
							}
						}
					}
				}
			}

			function frame()
			{
				// Time
				var now = new Date().getTime();
				var delta = now - (time || now);
				
				time = now;

				// Clearing
				ctx.rect(0, 0, cnv.width, cnv.height);
				ctx.fillStyle = "#222B42";
				ctx.fill();

				update(delta);
				transform();
				render();

				requestAnimationFrame(frame);
			}

			requestAnimationFrame(frame);
		</script>
	</body>
</html> 